import streamlit as st
import numpy as np
import sympy as sp
import matplotlib.pyplot as plt
import pandas as pd
from io import BytesIO
import base64
from sympy import Matrix, symbols
from sympy.solvers.solveset import linsolve
from matplotlib.colors import LinearSegmentedColormap
import plotly.graph_objects as go
import plotly.express as px

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="Sistema Linear Solver - Guia Universit√°rio",
    page_icon="üìê",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Fun√ß√µes utilit√°rias
def create_system_matrix(coeffs, constants, vars_count):
    """Cria a matriz aumentada do sistema"""
    A = []
    b = []
    
    for i in range(len(coeffs)):
        row = []
        for j in range(vars_count):
            if j < len(coeffs[i]):
                row.append(coeffs[i][j])
            else:
                row.append(0)
        A.append(row)
        b.append(constants[i])
    
    return np.array(A), np.array(b)

def gaussian_elimination_steps(A, b):
    """Implementa o m√©todo de elimina√ß√£o de Gauss com passos detalhados"""
    n = len(b)
    # Criar uma matriz aumentada
    augmented = np.column_stack((A, b))
    steps = [f"Matriz aumentada inicial:\n{augmented.copy()}"]
    
    # Elimina√ß√£o para frente (Forward Elimination)
    for i in range(n):
        # Procurar o maior elemento na coluna atual (piv√¥ parcial)
        max_row = i + np.argmax(np.abs(augmented[i:, i]))
        
        # Trocar linhas se necess√°rio
        if max_row != i:
            augmented[[i, max_row]] = augmented[[max_row, i]]
            steps.append(f"Trocar linha {i+1} com linha {max_row+1}:\n{augmented.copy()}")
        
        # Escalonar as linhas abaixo do piv√¥
        pivot = augmented[i, i]
        if abs(pivot) < 1e-10:  # Verificar se o piv√¥ √© zero
            continue
        
        for j in range(i + 1, n):
            factor = augmented[j, i] / pivot
            augmented[j] = augmented[j] - factor * augmented[i]
            if abs(factor) > 1e-10:  # Ignora opera√ß√µes com fator aproximadamente zero
                steps.append(f"Linha {j+1} = Linha {j+1} - {factor:.4f} √ó Linha {i+1}:\n{augmented.copy()}")
    
    # Verificar se o sistema √© poss√≠vel
    for i in range(n):
        if abs(augmented[i, :-1].sum()) < 1e-10 and abs(augmented[i, -1]) > 1e-10:
            steps.append("Sistema imposs√≠vel (SI): Equa√ß√£o inconsistente detectada.")
            return steps, None
    
    # Substitui√ß√£o reversa (Back Substitution)
    x = np.zeros(n)
    back_sub_steps = []
    
    for i in range(n-1, -1, -1):
        if abs(augmented[i, i]) < 1e-10:  # Verificar piv√¥ zero
            if abs(augmented[i, -1]) < 1e-10:
                back_sub_steps.append(f"Linha {i+1} √© 0 = 0, sistema possui infinitas solu√ß√µes (SPI).")
                return steps + back_sub_steps, None
            else:
                back_sub_steps.append(f"Linha {i+1} resulta em 0 = {augmented[i, -1]}, sistema imposs√≠vel (SI).")
                return steps + back_sub_steps, None
        
        substitution_terms = []
        for j in range(i+1, n):
            if abs(augmented[i, j]) > 1e-10:
                x[i] -= augmented[i, j] * x[j]
                substitution_terms.append(f"{augmented[i, j]:.4f}√óx_{j+1}")
        
        x[i] += augmented[i, -1]
        x[i] /= augmented[i, i]
        
        if substitution_terms:
            back_sub_steps.append(f"x_{i+1} = ({augmented[i, -1]:.4f} - ({' + '.join(substitution_terms)})) / {augmented[i, i]:.4f} = {x[i]:.4f}")
        else:
            back_sub_steps.append(f"x_{i+1} = {augmented[i, -1]:.4f} / {augmented[i, i]:.4f} = {x[i]:.4f}")
    
    steps.extend(back_sub_steps)
    return steps, x

def cramer_rule(A, b, detailed=True):
    """Implementa a regra de Cramer com passos detalhados"""
    n = len(b)
    det_A = np.linalg.det(A)
    steps = []
    
    if detailed:
        steps.append(f"Determinante da matriz principal A:\ndet(A) = {det_A:.4f}")
    
    if abs(det_A) < 1e-10:
        steps.append("O determinante da matriz √© zero. A regra de Cramer n√£o pode ser aplicada diretamente.")
        steps.append("O sistema pode ser SPI (infinitas solu√ß√µes) ou SI (imposs√≠vel).")
        return steps, None
    
    x = np.zeros(n)
    for i in range(n):
        A_i = A.copy()
        A_i[:, i] = b
        det_A_i = np.linalg.det(A_i)
        x[i] = det_A_i / det_A
        
        if detailed:
            steps.append(f"Determinante A_{i+1} (substituir coluna {i+1} por b):\ndet(A_{i+1}) = {det_A_i:.4f}")
            steps.append(f"x_{i+1} = det(A_{i+1}) / det(A) = {det_A_i:.4f} / {det_A:.4f} = {x[i]:.4f}")
    
    return steps, x

def matrix_inverse_method(A, b, detailed=True):
    """Resolve o sistema usando o m√©todo da matriz inversa"""
    steps = []
    try:
        # Calcular determinante para verificar inversibilidade
        det_A = np.linalg.det(A)
        if detailed:
            steps.append(f"Determinante da matriz A: det(A) = {det_A:.4f}")
        
        if abs(det_A) < 1e-10:
            steps.append("A matriz √© singular (determinante ‚âà 0). N√£o √© poss√≠vel encontrar a inversa.")
            steps.append("O sistema pode ser SPI (infinitas solu√ß√µes) ou SI (imposs√≠vel).")
            return steps, None
        
        # Calcular a matriz inversa
        A_inv = np.linalg.inv(A)
        if detailed:
            steps.append("Matriz inversa A‚Åª¬π:")
            steps.append(str(A_inv))
        
        # Calcular a solu√ß√£o
        x = np.dot(A_inv, b)
        if detailed:
            steps.append("Solu√ß√£o X = A‚Åª¬π √ó b:")
            steps.append(str(x))
        
        return steps, x
    except np.linalg.LinAlgError:
        steps.append("Erro ao calcular a inversa. A matriz √© singular.")
        return steps, None

def format_equation(coeffs, vars_list, equals_to):
    """Formata uma equa√ß√£o linear com vari√°veis nomeadas"""
    eq = ""
    first = True
    
    for i, coef in enumerate(coeffs):
        if abs(coef) < 1e-10:
            continue
            
        if coef > 0 and not first:
            eq += " + "
        elif coef < 0:
            eq += " - " if not first else "-"
            
        coef_abs = abs(coef)
        if abs(coef_abs - 1) < 1e-10:
            eq += f"{vars_list[i]}"
        else:
            eq += f"{coef_abs:.2f}{vars_list[i]}"
            
        first = False
    
    if not eq:
        eq = "0"
        
    eq += f" = {equals_to:.2f}"
    return eq

def plot_2d_system(A, b):
    """Gera um gr√°fico para um sistema 2x2"""
    if A.shape[0] < 2 or A.shape[1] < 2:
        return None
    
    fig, ax = plt.subplots(figsize=(10, 8))
    
    # Define o intervalo para x
    x = np.linspace(-10, 10, 1000)
    
    colors = ['#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6']
    
    for i in range(min(5, len(b))):
        # Calcula y para a linha i: a*x + b*y = c => y = (c - a*x) / b
        if abs(A[i, 1]) < 1e-10:  # Se b for zero, √© uma linha vertical
            ax.axvline(x=b[i]/A[i, 0], color=colors[i % len(colors)], 
                       label=f'Equa√ß√£o {i+1}: {format_equation(A[i], ["x", "y"], b[i])}')
        else:
            y = (b[i] - A[i, 0] * x) / A[i, 1]
            ax.plot(x, y, color=colors[i % len(colors)], 
                    label=f'Equa√ß√£o {i+1}: {format_equation(A[i], ["x", "y"], b[i])}')
    
    # Configura√ß√µes do gr√°fico
    ax.grid(True, alpha=0.3)
    ax.axhline(y=0, color='k', linestyle='-', alpha=0.3)
    ax.axvline(x=0, color='k', linestyle='-', alpha=0.3)
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_title('Representa√ß√£o Gr√°fica do Sistema')
    ax.legend()
    
    # Ajustar limites para visualiza√ß√£o adequada
    ax.set_xlim(-10, 10)
    ax.set_ylim(-10, 10)
    
    # Verificar se existe uma solu√ß√£o √∫nica
    try:
        solution = np.linalg.solve(A[:2, :2], b[:2])
        if np.all(np.isfinite(solution)):
            ax.plot(solution[0], solution[1], 'ko', markersize=8, label='Solu√ß√£o')
            ax.annotate(f'({solution[0]:.2f}, {solution[1]:.2f})', 
                        (solution[0], solution[1]), 
                        xytext=(10, 10), 
                        textcoords='offset points')
    except:
        pass
    
    return fig

def sympy_solve_system(A, b):
    """Resolve o sistema usando SymPy para obter solu√ß√µes exatas ou param√©tricas"""
    n = A.shape[1]  # N√∫mero de vari√°veis
    var_symbols = symbols(f'x1:{n+1}')
    
    # Criar o sistema de equa√ß√µes
    system = []
    for i in range(len(b)):
        lhs = sum(A[i, j] * var_symbols[j] for j in range(n))
        rhs = b[i]
        system.append(sp.Eq(lhs, rhs))
    
    # Resolver o sistema
    solution = sp.solve(system, var_symbols)
    
    return solution, var_symbols

def classify_system(A, b):
    """Classifica o sistema como SPD, SPI ou SI"""
    # Criar matriz ampliada
    augmented = np.column_stack((A, b))
    
    # Calcular postos
    rank_A = np.linalg.matrix_rank(A)
    rank_aug = np.linalg.matrix_rank(augmented)
    
    if rank_A < rank_aug:
        return "Sistema Imposs√≠vel (SI)"
    elif rank_A == rank_aug and rank_A == A.shape[1]:
        return "Sistema Poss√≠vel e Determinado (SPD)"
    else:
        return "Sistema Poss√≠vel e Indeterminado (SPI)"

def plot_3d_system(A, b):
    """Gera um gr√°fico 3D para um sistema com 3 vari√°veis"""
    if A.shape[1] < 3:
        return None
    
    # Criamos uma malha para os planos
    x = np.linspace(-5, 5, 20)
    y = np.linspace(-5, 5, 20)
    X, Y = np.meshgrid(x, y)
    
    fig = go.Figure()
    
    colors = ['blue', 'red', 'green', 'orange', 'purple']
    
    for i in range(min(5, len(b))):
        if abs(A[i, 2]) < 1e-10:  # Se o coeficiente de z for zero
            continue
            
        # Para a equa√ß√£o a*x + b*y + c*z = d, temos z = (d - a*x - b*y) / c
        Z = (b[i] - A[i, 0] * X - A[i, 1] * Y) / A[i, 2]
        
        fig.add_trace(go.Surface(
            x=X, y=Y, z=Z,
            opacity=0.7,
            colorscale=[[0, colors[i % len(colors)]], [1, colors[i % len(colors)]]],
            showscale=False,
            name=f'Equa√ß√£o {i+1}'
        ))
    
    # Se tivermos uma solu√ß√£o √∫nica, plot√°-la
    try:
        solution = np.linalg.solve(A[:3, :3], b[:3])
        if np.all(np.isfinite(solution)):
            fig.add_trace(go.Scatter3d(
                x=[solution[0]],
                y=[solution[1]],
                z=[solution[2]],
                mode='markers',
                marker=dict(size=8, color='black'),
                name='Solu√ß√£o'
            ))
    except:
        pass
    
    fig.update_layout(
        title='Representa√ß√£o 3D do Sistema',
        scene=dict(
            xaxis_title='x',
            yaxis_title='y',
            zaxis_title='z',
            aspectmode='cube'
        ),
        margin=dict(l=0, r=0, b=0, t=30)
    )
    
    return fig

def get_practice_exercise(level):
    """Gera exerc√≠cios de pr√°tica com base no n√≠vel de dificuldade"""
    if level == "F√°cil":
        # Sistema 2x2 com solu√ß√£o inteira
        A = np.array([[1, 1], [2, 1]])
        x = np.array([5, 3])  # Solu√ß√£o desejada
        b = np.dot(A, x)
        
        question = "Resolva o sistema de equa√ß√µes lineares:"
        equations = [
            f"{format_equation(A[0], ['x', 'y'], b[0])}",
            f"{format_equation(A[1], ['x', 'y'], b[1])}"
        ]
        
        return A, b, question, equations, x
        
    elif level == "M√©dio":
        # Sistema 3x3 com solu√ß√£o inteira
        A = np.array([[2, 1, -1], [3, -2, 1], [1, 2, 2]])
        x = np.array([1, 2, 3])  # Solu√ß√£o desejada
        b = np.dot(A, x)
        
        question = "Resolva o sistema de equa√ß√µes lineares:"
        equations = [
            f"{format_equation(A[0], ['x', 'y', 'z'], b[0])}",
            f"{format_equation(A[1], ['x', 'y', 'z'], b[1])}",
            f"{format_equation(A[2], ['x', 'y', 'z'], b[2])}"
        ]
        
        return A, b, question, equations, x
        
    else:  # Dif√≠cil
        # Sistema com solu√ß√£o n√£o inteira ou classifica√ß√£o especial
        r = np.random.choice(["SPD_complex", "SPI", "SI"])
        
        if r == "SPD_complex":
            A = np.array([[3, 1, -2], [2, -2, 1], [1, 5, -3]])
            x = np.array([1/3, 2/3, 1/3])  # Solu√ß√£o fracion√°ria
            b = np.dot(A, x)
            
        elif r == "SPI":
            # Sistema com infinitas solu√ß√µes
            A = np.array([[1, 2, 3], [2, 4, 6], [3, 5, 7]])
            b = np.array([6, 12, 15])
            x = None
            
        else:  # SI
            # Sistema imposs√≠vel
            A = np.array([[1, 2, 3], [2, 4, 6], [3, 6, 9]])
            b = np.array([6, 12, 19])  # Inconsistente
            x = None
        
        question = "Resolva e classifique o sistema de equa√ß√µes lineares:"
        equations = [
            f"{format_equation(A[0], ['x', 'y', 'z'], b[0])}",
            f"{format_equation(A[1], ['x', 'y', 'z'], b[1])}",
            f"{format_equation(A[2], ['x', 'y', 'z'], b[2])}"
        ]
        
        return A, b, question, equations, x

def check_user_answer(user_answer, solution, system_type):
    """Verifica a resposta do usu√°rio"""
    if system_type == "Sistema Poss√≠vel e Determinado (SPD)":
        try:
            user_values = [float(x.strip()) for x in user_answer.replace(',', ' ').split()]
            
            if len(user_values) != len(solution):
                return False, "N√∫mero incorreto de valores."
                
            # Verificar se a resposta est√° pr√≥xima da solu√ß√£o
            for u, s in zip(user_values, solution):
                if abs(u - s) > 1e-2:
                    return False, "Valores incorretos."
            
            return True, "Resposta correta!"
        except:
            return False, "Formato inv√°lido. Use n√∫meros separados por espa√ßos ou v√≠rgulas."
    elif system_type == "Sistema Poss√≠vel e Indeterminado (SPI)":
        return "SPI" in user_answer.upper(), "Verifique sua classifica√ß√£o do sistema."
    else:  # SI
        return "SI" in user_answer.upper() or "IMPOSS√çVEL" in user_answer.upper(), "Verifique sua classifica√ß√£o do sistema."

def get_reference_card(topic):
    """Retorna um cart√£o de refer√™ncia r√°pida para um t√≥pico espec√≠fico"""
    references = {
        "Classifica√ß√£o de Sistemas": """
        # Classifica√ß√£o de Sistemas Lineares
        
        Um sistema de equa√ß√µes lineares pode ser classificado como:
        
        ### Sistema Poss√≠vel e Determinado (SPD)
        - Possui **exatamente uma solu√ß√£o**
        - O determinante da matriz dos coeficientes √© **diferente de zero**
        - O posto da matriz dos coeficientes √© igual ao posto da matriz ampliada e igual ao n√∫mero de inc√≥gnitas
        
        ### Sistema Poss√≠vel e Indeterminado (SPI)
        - Possui **infinitas solu√ß√µes**
        - O posto da matriz dos coeficientes √© igual ao posto da matriz ampliada
        - O posto √© menor que o n√∫mero de inc√≥gnitas
        
        ### Sistema Imposs√≠vel (SI)
        - **N√£o possui solu√ß√£o**
        - O posto da matriz dos coeficientes √© menor que o posto da matriz ampliada
        """,
        
        "M√©todo de Elimina√ß√£o de Gauss": """
        # M√©todo de Elimina√ß√£o de Gauss
        
        O m√©todo de elimina√ß√£o de Gauss consiste em transformar o sistema em uma forma triangular atrav√©s de opera√ß√µes elementares:
        
        1. **Escalonamento para a forma triangular**:
           - Trocar linhas de posi√ß√£o
           - Multiplicar uma linha por uma constante n√£o nula
           - Substituir uma linha pela soma dela com um m√∫ltiplo de outra
           
        2. **Substitui√ß√£o reversa**:
           - Uma vez que o sistema est√° na forma triangular, resolver as inc√≥gnitas de baixo para cima
           
        O objetivo √© transformar a matriz aumentada em uma matriz escalonada na forma:
        
        ```
        | a‚ÇÅ‚ÇÅ a‚ÇÅ‚ÇÇ a‚ÇÅ‚ÇÉ ... | b‚ÇÅ |
        | 0   a‚ÇÇ‚ÇÇ a‚ÇÇ‚ÇÉ ... | b‚ÇÇ |
        | 0   0   a‚ÇÉ‚ÇÉ ... | b‚ÇÉ |
        | ...             | ... |
        ```
        """,
        
        "Regra de Cramer": """
        # Regra de Cramer
        
        A regra de Cramer √© um m√©todo para resolver sistemas lineares usando determinantes. Para um sistema de n equa√ß√µes e n inc√≥gnitas:
        
        1. Calcular o determinante D da matriz dos coeficientes
        2. Para cada inc√≥gnita x·µ¢, substituir a coluna i da matriz pelos termos independentes, obtendo o determinante D·µ¢
        3. A solu√ß√£o para cada inc√≥gnita √© x·µ¢ = D·µ¢/D
        
        **Limita√ß√µes**:
        - Aplic√°vel apenas a sistemas SPD (quando D ‚â† 0)
        - Computacionalmente ineficiente para sistemas grandes
        
        Para um sistema 2√ó2:
        ```
        a‚ÇÅx + b‚ÇÅy = c‚ÇÅ
        a‚ÇÇx + b‚ÇÇy = c‚ÇÇ
        ```
        
        x = |c‚ÇÅ b‚ÇÅ|/|a‚ÇÅ b‚ÇÅ| = (c‚ÇÅb‚ÇÇ - b‚ÇÅc‚ÇÇ)/(a‚ÇÅb‚ÇÇ - b‚ÇÅa‚ÇÇ)
            |c‚ÇÇ b‚ÇÇ| |a‚ÇÇ b‚ÇÇ|
            
        y = |a‚ÇÅ c‚ÇÅ|/|a‚ÇÅ b‚ÇÅ| = (a‚ÇÅc‚ÇÇ - c‚ÇÅa‚ÇÇ)/(a‚ÇÅb‚ÇÇ - b‚ÇÅa‚ÇÇ)
            |a‚ÇÇ c‚ÇÇ| |a‚ÇÇ b‚ÇÇ|
        """,
        
        "M√©todo da Matriz Inversa": """
        # M√©todo da Matriz Inversa
        
        Para um sistema na forma matricial AX = B, a solu√ß√£o √© dada por X = A‚Åª¬πB, onde A‚Åª¬π √© a matriz inversa de A.
        
        **Procedimento**:
        1. Verificar se a matriz A √© invers√≠vel (det(A) ‚â† 0)
        2. Calcular a matriz inversa A‚Åª¬π
        3. Multiplicar A‚Åª¬π por B para obter X
        
        **Observa√ß√µes**:
        - Aplic√°vel apenas quando a matriz A √© invers√≠vel (sistemas SPD)
        - Para matrizes 2√ó2, a inversa √© calculada como:
          ```
          |a b|‚Åª¬π = 1/(ad-bc) |d -b|
          |c d|              |-c  a|
          ```
        """,
        
        "Interpreta√ß√£o Geom√©trica": """
        # Interpreta√ß√£o Geom√©trica de Sistemas Lineares
        
        ### Sistemas 2√ó2
        - Cada equa√ß√£o representa uma **reta** no plano cartesiano
        - **SPD**: As retas se intersectam em um √∫nico ponto
        - **SPI**: As retas s√£o coincidentes (infinitos pontos de intersec√ß√£o)
        - **SI**: As retas s√£o paralelas (nenhum ponto de intersec√ß√£o)
        
        ### Sistemas 3√ó3
        - Cada equa√ß√£o representa um **plano** no espa√ßo tridimensional
        - **SPD**: Os tr√™s planos se intersectam em um √∫nico ponto
        - **SPI**: Os planos se intersectam em uma reta ou em um plano
        - **SI**: N√£o h√° ponto comum aos tr√™s planos
        
        ### Determinante e Volume
        - O determinante da matriz dos coeficientes est√° relacionado ao volume do paralelep√≠pedo formado pelos vetores-linha
        - Determinante zero: os vetores s√£o linearmente dependentes (coplanares ou colineares)
        """,
        
        "Teorema de Rouch√©-Capelli": """
        # Teorema de Rouch√©-Capelli
        
        Este teorema estabelece as condi√ß√µes para a exist√™ncia e unicidade de solu√ß√µes em sistemas lineares.
        
        **Enunciado**:
        Um sistema de equa√ß√µes lineares √©:
        
        1. **Compat√≠vel** (tem solu√ß√£o) se e somente se o posto da matriz dos coeficientes √© igual ao posto da matriz ampliada.
           - Se posto(A) = posto([A|B]) = n√∫mero de inc√≥gnitas ‚Üí **SPD** (solu√ß√£o √∫nica)
           - Se posto(A) = posto([A|B]) < n√∫mero de inc√≥gnitas ‚Üí **SPI** (infinitas solu√ß√µes)
        
        2. **Incompat√≠vel** (sem solu√ß√£o) se e somente se o posto da matriz dos coeficientes √© menor que o posto da matriz ampliada.
           - Se posto(A) < posto([A|B]) ‚Üí **SI**
        
        O **posto** de uma matriz √© o n√∫mero de linhas (ou colunas) linearmente independentes.
        """
    }
    
    return references.get(topic, "T√≥pico n√£o encontrado na base de conhecimento.")

def get_example_system(example_type):
    """Retorna um exemplo de sistema linear baseado no tipo selecionado"""
    examples = {
        "Sistema 2√ó2 (SPD)": {
            "title": "Sistema 2√ó2 com Solu√ß√£o √önica",
            "equations": ["x + y = 5", "2x - y = 1"],
            "solution": "x = 2, y = 3",
            "A": np.array([[1, 1], [2, -1]], dtype=float),
            "b": np.array([5, 1], dtype=float),
            "explanation": """
            Este √© um exemplo de um Sistema Poss√≠vel e Determinado (SPD) com duas equa√ß√µes e duas inc√≥gnitas.
            
            As duas retas se intersectam em um √∫nico ponto (2, 3), que √© a solu√ß√£o do sistema.
            
            **Verifica√ß√£o**:
            - Equa√ß√£o 1: 2 + 3 = 5 ‚úì
            - Equa√ß√£o 2: 2(2) - 3 = 4 - 3 = 1 ‚úì
            """
        },
        "Sistema 2√ó2 (SPI)": {
            "title": "Sistema 2√ó2 com Infinitas Solu√ß√µes",
            "equations": ["2x + 3y = 12", "4x + 6y = 24"],
            "solution": "x = t, y = (12-2t)/3, onde t √© um par√¢metro livre",
            "A": np.array([[2, 3], [4, 6]], dtype=float),
            "b": np.array([12, 24], dtype=float),
            "explanation": """
            Este √© um exemplo de um Sistema Poss√≠vel e Indeterminado (SPI).
            
            Observe que a segunda equa√ß√£o √© simplesmente um m√∫ltiplo da primeira (basta multiplicar a primeira por 2). 
            Portanto, as duas equa√ß√µes representam a mesma reta no plano, resultando em infinitas solu√ß√µes.
            
            A solu√ß√£o pode ser expressa na forma param√©trica:
            - x = t (par√¢metro livre)
            - y = (12 - 2t)/3
            
            Para qualquer valor de t, o par (t, (12-2t)/3) ser√° uma solu√ß√£o v√°lida para o sistema.
            """
        },
        "Sistema 2√ó2 (SI)": {
            "title": "Sistema 2√ó2 Imposs√≠vel",
            "equations": ["2x + 3y = 12", "2x + 3y = 15"],
            "solution": "Sem solu√ß√£o",
            "A": np.array([[2, 3], [2, 3]], dtype=float),
            "b": np.array([12, 15], dtype=float),
            "explanation": """
            Este √© um exemplo de um Sistema Imposs√≠vel (SI).
            
            As duas equa√ß√µes representam retas paralelas no plano, pois t√™m os mesmos coeficientes para x e y, 
            mas termos independentes diferentes. Geometricamente, isso significa que as retas nunca se intersectam.
            
            A inconsist√™ncia √© evidente: a mesma combina√ß√£o de x e y (2x + 3y) n√£o pode ser simultaneamente igual a 12 e 15.
            """
        },
        "Sistema 3√ó3 (SPD)": {
            "title": "Sistema 3√ó3 com Solu√ß√£o √önica",
            "equations": ["x + y + z = 6", "2x - y + z = 3", "x + 2y + 3z = 14"],
            "solution": "x = 1, y = 2, z = 3",
            "A": np.array([[1, 1, 1], [2, -1, 1], [1, 2, 3]], dtype=float),
            "b": np.array([6, 3, 14], dtype=float),
            "explanation": """
            Este √© um exemplo de um Sistema Poss√≠vel e Determinado (SPD) com tr√™s equa√ß√µes e tr√™s inc√≥gnitas.
            
            Os tr√™s planos representados pelas equa√ß√µes se intersectam em um √∫nico ponto (1, 2, 3).
            **Verifica√ß√£o**:
            - Equa√ß√£o 1: 1 + 2 + 3 = 6 ‚úì
            - Equa√ß√£o 2: 2(1) - 2 + 3 = 2 - 2 + 3 = 3 ‚úì
            - Equa√ß√£o 3: 1 + 2(2) + 3(3) = 1 + 4 + 9 = 14 ‚úì
            """
        },
        "Sistema 3√ó3 (SPI)": {
            "title": "Sistema 3√ó3 com Infinitas Solu√ß√µes",
            "equations": ["x + y + z = 6", "2x + 2y + 2z = 12", "x - y + 2z = 7"],
            "solution": "z = t (par√¢metro), y = 2-t, x = 4+t, onde t √© um par√¢metro livre",
            "A": np.array([[1, 1, 1], [2, 2, 2], [1, -1, 2]], dtype=float),
            "b": np.array([6, 12, 7], dtype=float),
            "explanation": """
            Este √© um exemplo de um Sistema Poss√≠vel e Indeterminado (SPI) com tr√™s equa√ß√µes e tr√™s inc√≥gnitas.
            
            Note que a segunda equa√ß√£o √© um m√∫ltiplo da primeira (basta multiplicar a primeira por 2). Isso significa 
            que temos efetivamente apenas duas equa√ß√µes independentes e tr√™s inc√≥gnitas, resultando em infinitas solu√ß√µes.
            
            Geometricamente, dois dos planos s√£o coincidentes, e a interse√ß√£o deles com o terceiro plano forma uma reta,
            n√£o um ponto √∫nico.
            
            A solu√ß√£o pode ser expressa na forma param√©trica:
            - z = t (par√¢metro livre)
            - y = 2 - t
            - x = 4 + t
            
            Para qualquer valor de t, a tripla (4+t, 2-t, t) ser√° uma solu√ß√£o v√°lida.
            """
        },
        "Sistema 3√ó3 (SI)": {
            "title": "Sistema 3√ó3 Imposs√≠vel",
            "equations": ["x + y + z = 6", "2x + 2y + 2z = 12", "3x + 3y + 3z = 21"],
            "solution": "Sem solu√ß√£o",
            "A": np.array([[1, 1, 1], [2, 2, 2], [3, 3, 3]], dtype=float),
            "b": np.array([6, 12, 21], dtype=float),
            "explanation": """
            Este √© um exemplo de um Sistema Imposs√≠vel (SI) com tr√™s equa√ß√µes e tr√™s inc√≥gnitas.
            
            Observe que a segunda equa√ß√£o √© um m√∫ltiplo da primeira (multiplique a primeira por 2),
            e a terceira deveria ser um m√∫ltiplo da primeira (multiplique a primeira por 3), mas o termo
            independente est√° incorreto: 3(6) = 18, n√£o 21.
            
            Geometricamente, isso significa que o terceiro plano √© paralelo aos outros dois (que s√£o coincidentes),
            tornando imposs√≠vel que os tr√™s planos tenham um ponto comum de interse√ß√£o.
            
            A inconsist√™ncia √© evidente ao dividir cada equa√ß√£o pelos coeficientes:
            - Equa√ß√£o 1: x + y + z = 6 ‚Üí x + y + z = 6
            - Equa√ß√£o 2: 2x + 2y + 2z = 12 ‚Üí x + y + z = 6
            - Equa√ß√£o 3: 3x + 3y + 3z = 21 ‚Üí x + y + z = 7
            
            A mesma combina√ß√£o x + y + z n√£o pode ser simultaneamente igual a 6 e 7.
            """
        },
        "Aplica√ß√£o: Mistura": {
            "title": "Problema de Mistura",
            "equations": ["x + y + z = 100", "0.1x + 0.2y + 0.4z = 25", "x + 0 + 0 = 30"],
            "solution": "x = 30, y = 50, z = 20",
            "A": np.array([[1, 1, 1], [0.1, 0.2, 0.4], [1, 0, 0]], dtype=float),
            "b": np.array([100, 25, 30], dtype=float),
            "explanation": """
            **Problema**: Uma mistura cont√©m tr√™s ingredientes A, B e C. Se a mistura total √© de 100kg e a quantidade do 
            ingrediente A √© de 30kg, e sabendo que o ingrediente A tem 10% de um composto X, B tem 20% e C tem 40%, e a 
            mistura final deve ter 25kg do composto X, determine as quantidades dos ingredientes B e C.
            
            **Modelagem do Sistema**:
            - Sejam x, y e z as quantidades (em kg) dos ingredientes A, B e C, respectivamente
            - Equa√ß√£o 1: x + y + z = 100 (quantidade total da mistura)
            - Equa√ß√£o 2: 0.1x + 0.2y + 0.4z = 25 (quantidade do composto X)
            - Equa√ß√£o 3: x = 30 (quantidade conhecida do ingrediente A)
            
            **Solu√ß√£o**:
            - x = 30 (dado do problema)
            - Substituindo na Equa√ß√£o 1: 30 + y + z = 100 ‚Üí y + z = 70
            - Substituindo na Equa√ß√£o 2: 0.1(30) + 0.2y + 0.4z = 25 ‚Üí 3 + 0.2y + 0.4z = 25 ‚Üí 0.2y + 0.4z = 22
            
            Temos ent√£o o sistema 2√ó2:
            - y + z = 70
            - 0.2y + 0.4z = 22
            
            Multiplicando a segunda equa√ß√£o por 5: y + 2z = 110
            Subtraindo da primeira: -z = -40 ‚Üí z = 20
            
            Substituindo: y + 20 = 70 ‚Üí y = 50
            
            Portanto, a mistura deve conter:
            - 30kg do ingrediente A
            - 50kg do ingrediente B
            - 20kg do ingrediente C
            """
        },
        "Aplica√ß√£o: Circuitos": {
            "title": "Problema de Circuito El√©trico",
            "equations": ["I‚ÇÅ - I‚ÇÇ - I‚ÇÉ = 0", "10I‚ÇÅ - 5I‚ÇÉ = 20", "5I‚ÇÇ + 15I‚ÇÉ = 0"],
            "solution": "I‚ÇÅ = 5A, I‚ÇÇ = -3A, I‚ÇÉ = 1A",
            "A": np.array([[1, -1, -1], [10, 0, -5], [0, 5, 15]], dtype=float),
            "b": np.array([0, 20, 0], dtype=float),
            "explanation": """
            **Problema**: Um circuito el√©trico possui tr√™s correntes I‚ÇÅ, I‚ÇÇ e I‚ÇÉ. 
            Na jun√ß√£o das correntes, temos I‚ÇÅ = I‚ÇÇ + I‚ÇÉ (lei de Kirchhoff para correntes). 
            O circuito cont√©m resistores com as seguintes quedas de tens√£o: 10I‚ÇÅ - 5I‚ÇÉ = 20V e 5I‚ÇÇ + 15I‚ÇÉ = 0V.
            Determine as correntes no circuito.
            
            **Modelagem do Sistema**:
            - Equa√ß√£o 1: I‚ÇÅ - I‚ÇÇ - I‚ÇÉ = 0 (conserva√ß√£o de corrente na jun√ß√£o)
            - Equa√ß√£o 2: 10I‚ÇÅ - 5I‚ÇÉ = 20 (queda de tens√£o no primeiro caminho)
            - Equa√ß√£o 3: 5I‚ÇÇ + 15I‚ÇÉ = 0 (queda de tens√£o no segundo caminho)
            
            **Solu√ß√£o**:
            Resolvendo o sistema, obtemos:
            - I‚ÇÅ = 5A (corrente de entrada)
            - I‚ÇÇ = -3A (corrente no segundo caminho, negativa indica dire√ß√£o contr√°ria)
            - I‚ÇÉ = 1A (corrente no terceiro caminho)
            
            **Verifica√ß√£o**:
            - Equa√ß√£o 1: 5 - (-3) - 1 = 5 + 3 - 1 = 7 ‚â† 0
            
            Parece haver um erro na solu√ß√£o. Vamos conferir novamente:
            
            Da Equa√ß√£o 3: 5I‚ÇÇ + 15I‚ÇÉ = 0 ‚Üí I‚ÇÇ = -3I‚ÇÉ
            Substituindo na Equa√ß√£o 1: I‚ÇÅ - (-3I‚ÇÉ) - I‚ÇÉ = 0 ‚Üí I‚ÇÅ = -2I‚ÇÉ
            Substituindo na Equa√ß√£o 2: 10(-2I‚ÇÉ) - 5I‚ÇÉ = 20 ‚Üí -20I‚ÇÉ - 5I‚ÇÉ = 20 ‚Üí -25I‚ÇÉ = 20 ‚Üí I‚ÇÉ = -0.8
            
            Portanto:
            - I‚ÇÉ = -0.8A
            - I‚ÇÇ = -3(-0.8) = 2.4A
            - I‚ÇÅ = -2(-0.8) = 1.6A
            
            **Verifica√ß√£o corrigida**:
            - Equa√ß√£o 1: 1.6 - 2.4 - (-0.8) = 1.6 - 2.4 + 0.8 = 0 ‚úì
            - Equa√ß√£o 2: 10(1.6) - 5(-0.8) = 16 + 4 = 20 ‚úì
            - Equa√ß√£o 3: 5(2.4) + 15(-0.8) = 12 - 12 = 0 ‚úì
            """
        }
    }
    
    return examples.get(example_type, {"title": "Exemplo n√£o encontrado", "equations": [], "solution": "", "explanation": "", "A": None, "b": None})

# Configura√ß√£o da interface

def main():
    st.sidebar.image("https://i.imgur.com/JJ58f0d.png", width=280)
    st.sidebar.title("Navega√ß√£o")
    
    pages = ["In√≠cio", "Resolver Sistema", "Teoria", "Exerc√≠cios", "Exemplos", "Refer√™ncia R√°pida"]
    selection = st.sidebar.radio("Ir para:", pages)
    
    if selection == "In√≠cio":
        show_home_page()
    elif selection == "Resolver Sistema":
        show_solver_page()
    elif selection == "Teoria":
        show_theory_page()
    elif selection == "Exerc√≠cios":
        show_exercises_page()
    elif selection == "Exemplos":
        show_examples_page()
    else:
        show_reference_page()

def show_home_page():
    st.title("üìê Sistema Linear Solver")
    st.subheader("Guia Universit√°rio de Sistemas Lineares")
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.markdown("""
        ## Bem-vindo √† sua ferramenta de estudo de Sistemas Lineares!
        
        Este aplicativo foi desenvolvido para ajudar estudantes universit√°rios a entender, resolver e visualizar 
        sistemas de equa√ß√µes lineares usando diferentes m√©todos.
        
        ### O que voc√™ pode fazer aqui:
        
        - **Resolver sistemas** lineares usando diversos m√©todos
        - **Visualizar graficamente** sistemas de 2 e 3 vari√°veis
        - **Aprender a teoria** por tr√°s da √°lgebra linear
        - **Praticar** com exerc√≠cios e exemplos resolvidos
        - **Consultar refer√™ncias r√°pidas** sobre m√©todos e conceitos
        
        ### Come√ßar a usar:
        
        Use o menu de navega√ß√£o √† esquerda para explorar as diferentes funcionalidades do aplicativo.
        """)
        
        st.info("""
        **Dica:** Se voc√™ √© novo no estudo de sistemas lineares, recomendamos come√ßar pela se√ß√£o "Teoria" 
        para entender os conceitos fundamentais, e depois explorar os "Exemplos" para ver aplica√ß√µes pr√°ticas.
        """)
        
    with col2:
        st.markdown("""
        ### Recursos Populares:
        """)
        
        if st.button("üîç Resolver um Sistema", key="home_btn1"):
            st.session_state.page = "Resolver Sistema"
            st.experimental_rerun()
            
        if st.button("üìö Aprender a Teoria", key="home_btn2"):
            st.session_state.page = "Teoria"
            st.experimental_rerun()
            
        if st.button("‚úèÔ∏è Praticar com Exerc√≠cios", key="home_btn3"):
            st.session_state.page = "Exerc√≠cios"
            st.experimental_rerun()
            
        if st.button("üìã Ver Exemplos Resolvidos", key="home_btn4"):
            st.session_state.page = "Exemplos"
            st.experimental_rerun()
        
        st.markdown("---")
        st.markdown("""
        ### Pr√≥xima Aula:
        üìÖ **Determinantes e Matrizes Inversas**
        üïí Amanh√£, 14h00
        """)

def show_solver_page():
    st.title("üßÆ Resolver Sistema Linear")
    
    tab1, tab2, tab3 = st.tabs(["üìù Inserir Sistema", "üîç Resultados", "üìä Visualiza√ß√£o"])
    
    with tab1:
        st.subheader("Insira seu sistema de equa√ß√µes lineares")
        
        col1, col2 = st.columns([3, 1])
        
        with col1:
            system_input_method = st.radio(
                "M√©todo de entrada:",
                ["Manual (Coeficientes)", "Equa√ß√µes (Texto)"],
                horizontal=True
            )
            
        with col2:
            vars_count = st.number_input("N√∫mero de vari√°veis:", min_value=2, max_value=4, value=2)
            
        if system_input_method == "Manual (Coeficientes)":
            equations_count = st.number_input("N√∫mero de equa√ß√µes:", min_value=1, max_value=5, value=vars_count)
            
            coeffs = []
            constants = []
            
            st.markdown("### Insira os coeficientes e termos independentes")
            
            var_names = ["x", "y", "z", "w"][:vars_count]
            
            for i in range(equations_count):
                cols = st.columns(vars_count + 1)
                
                eq_coeffs = []
                for j in range(vars_count):
                    with cols[j]:
                        coef = st.number_input(
                            f"Coeficiente de {var_names[j]} na equa√ß√£o {i+1}:",
                            value=1.0 if i == j else 0.0,
                            step=0.1,
                            format="%.2f",
                            key=f"coef_{i}_{j}"
                        )
                        eq_coeffs.append(coef)
                
                with cols[-1]:
                    const = st.number_input(
                        f"Termo independente da equa√ß√£o {i+1}:",
                        value=0.0,
                        step=0.1,
                        format="%.2f",
                        key=f"const_{i}"
                    )
                
                coeffs.append(eq_coeffs)
                constants.append(const)
                
                # Mostrar a equa√ß√£o formatada
                eq_str = format_equation(eq_coeffs, var_names, const)
                st.write(f"Equa√ß√£o {i+1}: {eq_str}")
                
        else:  # Entrada por texto
            st.markdown("""
            Insira cada equa√ß√£o em uma linha separada, usando a sintaxe:
            ```
            a*x + b*y + c*z = d
            ```
            Exemplo:
            ```
            2*x + 3*y = 5
            x - y = 1
            ```
            """)
            
            equations_text = st.text_area(
                "Equa√ß√µes (uma por linha):",
                height=150,
                help="Insira uma equa√ß√£o por linha. Use * para multiplica√ß√£o.",
                value="x + y = 10\n2*x - y = 5"
            )
            
            try:
                # Processar as equa√ß√µes de texto
                equations = equations_text.strip().split('\n')
                coeffs = []
                constants = []
                
                var_symbols = []
                for i in range(vars_count):
                    if i < len(["x", "y", "z", "w"]):
                        var_symbols.append(sp.symbols(["x", "y", "z", "w"][i]))
                
                for eq_text in equations:
                    if not eq_text.strip():
                        continue
                        
                    # Substituir = por - ( para padronizar
                    eq_text = eq_text.replace("=", "-(") + ")"
                    
                    # Converter para express√£o sympy
                    expr = sp.sympify(eq_text)
                    
                    # Extrair coeficientes
                    eq_coeffs = []
                    for var in var_symbols:
                        coef = expr.coeff(var)
                        eq_coeffs.append(float(coef))
                    
                    # Extrair termo constante
                    const = -float(expr.subs([(var, 0) for var in var_symbols]))
                    
                    coeffs.append(eq_coeffs)
                    constants.append(const)
                
                # Mostrar as equa√ß√µes interpretadas
                st.markdown("### Equa√ß√µes interpretadas:")
                for i, (eq_coef, eq_const) in enumerate(zip(coeffs, constants)):
                    var_names = ["x", "y", "z", "w"][:vars_count]
                    eq_str = format_equation(eq_coef, var_names, eq_const)
                    st.write(f"Equa√ß√£o {i+1}: {eq_str}")
                    
            except Exception as e:
                st.error(f"Erro ao processar as equa√ß√µes: {str(e)}")
                st.stop()
        
        # M√©todo de resolu√ß√£o
        st.markdown("### M√©todo de Resolu√ß√£o")
        
        col1, col2 = st.columns(2)
        
        with col1:
            solution_method = st.selectbox(
                "Escolha o m√©todo:",
                ["Elimina√ß√£o de Gauss", "Regra de Cramer", "Matriz Inversa", "Todos os M√©todos"]
            )
            
        with col2:
            show_steps = st.checkbox("Mostrar passos detalhados", value=True)
        
        A, b = create_system_matrix(coeffs, constants, vars_count)
        
        # Bot√£o para resolver
        if st.button("Resolver Sistema", type="primary"):
            st.session_state.system_solved = True
            st.session_state.A = A
            st.session_state.b = b
            st.session_state.vars_count = vars_count
            st.session_state.solution_method = solution_method
            st.session_state.show_steps = show_steps
            st.session_state.system_classification = classify_system(A, b)
            
            # Computar solu√ß√µes pelos diferentes m√©todos
            results = {}
            
            if solution_method in ["Elimina√ß√£o de Gauss", "Todos os M√©todos"]:
                steps, solution = gaussian_elimination_steps(A, b)
                results["Elimina√ß√£o de Gauss"] = {"steps": steps, "solution": solution}
                
            if vars_count <= 4 and solution_method in ["Regra de Cramer", "Todos os M√©todos"]:
                steps, solution = cramer_rule(A, b, detailed=show_steps)
                results["Regra de Cramer"] = {"steps": steps, "solution": solution}
                
            if solution_method in ["Matriz Inversa", "Todos os M√©todos"]:
                steps, solution = matrix_inverse_method(A, b, detailed=show_steps)
                results["Matriz Inversa"] = {"steps": steps, "solution": solution}
                
            st.session_state.results = results
            
            # Mudar para a aba de resultados
            st.experimental_rerun()
            
    with tab2:
        if not hasattr(st.session_state, 'system_solved') or not st.session_state.system_solved:
            st.info("Insira e resolva um sistema na aba 'Inserir Sistema'")
            st.stop()
        
        st.subheader("Resultados da Resolu√ß√£o")
        
        # Exibir classifica√ß√£o do sistema
        st.markdown(f"**Classifica√ß√£o do Sistema:** {st.session_state.system_classification}")
        
        # Exibir solu√ß√£o para cada m√©todo
        for method, result in st.session_state.results.items():
            st.markdown(f"### {method}")
            
            steps = result["steps"]
            solution = result["solution"]
            
            if solution is not None:
                st.markdown("**Solu√ß√£o encontrada:**")
                for i, val in enumerate(solution):
                    var_name = ["x", "y", "z", "w"][i] if i < 4 else f"x_{i+1}"
                    st.markdown(f"- {var_name} = {val:.4f}")
            else:
                st.write("N√£o foi poss√≠vel encontrar uma solu√ß√£o √∫nica por este m√©todo.")
            
            if st.session_state.show_steps:
                with st.expander("Ver passos detalhados", expanded=False):
                    for step in steps:
                        st.write(step)
        
        # Adicionar interpreta√ß√£o da solu√ß√£o
        if st.session_state.system_classification == "Sistema Poss√≠vel e Determinado (SPD)":
            st.markdown("### Interpreta√ß√£o da Solu√ß√£o")
            st.write("O sistema possui uma √∫nica solu√ß√£o, que satisfaz todas as equa√ß√µes simultaneamente.")
            
            # Verifica√ß√£o da solu√ß√£o
            st.markdown("### Verifica√ß√£o")
            
            # Obter uma solu√ß√£o v√°lida (qualquer uma)
            solution = None
            for result in st.session_state.results.values():
                if result["solution"] is not None:
                    solution = result["solution"]
                    break
            
            if solution is not None:
                A = st.session_state.A
                b = st.session_state.b
                
                for i in range(len(b)):
                    eq_result = np.dot(A[i], solution)
                    is_correct = abs(eq_result - b[i]) < 1e-10
                    
                    var_names = ["x", "y", "z", "w"][:st.session_state.vars_count]
                    eq_str = format_equation(A[i], var_names, b[i])
                    
                    substitution = " + ".join([f"{A[i][j]:.2f} √ó {solution[j]:.4f}" for j in range(len(solution)) if abs(A[i][j]) > 1e-10])
                    
                    result_str = f"{eq_result:.4f} ‚âà {b[i]:.4f}" if is_correct else f"{eq_result:.4f} ‚â† {b[i]:.4f}"
                    
                    if is_correct:
                        st.success(f"Equa√ß√£o {i+1}: {eq_str}\n{substitution} = {result_str} ‚úì")
                    else:
                        st.error(f"Equa√ß√£o {i+1}: {eq_str}\n{substitution} = {result_str} ‚úó")
                        
        elif st.session_state.system_classification == "Sistema Poss√≠vel e Indeterminado (SPI)":
            st.markdown("### Interpreta√ß√£o da Solu√ß√£o")
            st.write("""
            O sistema possui infinitas solu√ß√µes. Isso ocorre porque h√° menos equa√ß√µes linearmente independentes
            do que vari√°veis, criando um espa√ßo de solu√ß√µes poss√≠veis.
            
            A solu√ß√£o pode ser expressa de forma param√©trica, onde uma ou mais vari√°veis s√£o expressas em termos
            de par√¢metros livres.
            """)
            
            # Tentar obter solu√ß√£o simb√≥lica
            try:
                A = st.session_state.A
                b = st.session_state.b
                symbolic_solution, var_symbols = sympy_solve_system(A, b)
                
                if symbolic_solution:
                    st.markdown("### Solu√ß√£o Param√©trica")
                    
                    if isinstance(symbolic_solution, dict):
                        for var, expr in symbolic_solution.items():
                            st.latex(f"{sp.latex(var)} = {sp.latex(expr)}")
                    else:
                        st.latex(sp.latex(symbolic_solution))
            except:
                st.warning("N√£o foi poss√≠vel obter uma representa√ß√£o param√©trica da solu√ß√£o.")
                
        else:  # Sistema Imposs√≠vel
            st.markdown("### Interpreta√ß√£o da Solu√ß√£o")
            st.write("""
            O sistema n√£o possui solu√ß√£o. Isso ocorre porque as equa√ß√µes s√£o inconsistentes entre si,
            ou seja, n√£o existe um conjunto de valores para as vari√°veis que satisfa√ßa todas as equa√ß√µes
            simultaneamente.
            
            Geometricamente, isso pode ser interpretado como:
            - Em 2D: retas paralelas que nunca se intersectam
            - Em 3D: planos sem ponto comum de interse√ß√£o
            """)
    
    with tab3:
        if not hasattr(st.session_state, 'system_solved') or not st.session_state.system_solved:
            st.info("Insira e resolva um sistema na aba 'Inserir Sistema'")
            st.stop()
        
        st.subheader("Visualiza√ß√£o Gr√°fica")
        
        if st.session_state.vars_count == 2:
            try:
                fig = plot_2d_system(st.session_state.A, st.session_state.b)
                if fig:
                    st.pyplot(fig)
                    
                    # Adicionar interpreta√ß√£o geom√©trica
                    st.markdown("### Interpreta√ß√£o Geom√©trica")
                    
                    if st.session_state.system_classification == "Sistema Poss√≠vel e Determinado (SPD)":
                        st.write("""
                        Cada equa√ß√£o do sistema representa uma reta no plano cartesiano.
                        A solu√ß√£o do sistema √© o ponto de interse√ß√£o entre estas retas.
                        """)
                    elif st.session_state.system_classification == "Sistema Poss√≠vel e Indeterminado (SPI)":
                        st.write("""
                        As retas s√£o coincidentes (sobrepostas), o que significa que qualquer
                        ponto em uma das retas √© uma solu√ß√£o v√°lida para o sistema.
                        """)
                    else:  # SI
                        st.write("""
                        As retas s√£o paralelas, o que indica que n√£o h√° ponto de interse√ß√£o
                        e, portanto, o sistema n√£o possui solu√ß√£o.
                        """)
                else:
                    st.warning("N√£o foi poss√≠vel gerar a visualiza√ß√£o do sistema.")
            except Exception as e:
                st.error(f"Erro ao gerar o gr√°fico: {str(e)}")
                
        elif st.session_state.vars_count == 3:
            try:
                fig = plot_3d_system(st.session_state.A, st.session_state.b)
                if fig:
                    st.plotly_chart(fig, use_container_width=True)
                    
                    # Adicionar interpreta√ß√£o geom√©trica
                    st.markdown("### Interpreta√ß√£o Geom√©trica")
                    
                    if st.session_state.system_classification == "Sistema Poss√≠vel e Determinado (SPD)":
                        st.write("""
                        Cada equa√ß√£o do sistema representa um plano no espa√ßo tridimensional.
                        A solu√ß√£o do sistema √© o ponto √∫nico de interse√ß√£o entre estes planos.
                        """)
                    elif st.session_state.system_classification == "Sistema Poss√≠vel e Indeterminado (SPI)":
                        st.write("""
                        Os planos se intersectam em uma reta ou em um plano comum,
                        resultando em infinitas solu√ß√µes poss√≠veis.
                        """)
                    else:  # SI
                        st.write("""
                        Os planos n√£o possuem um ponto comum de interse√ß√£o,
                        o que indica que o sistema n√£o tem solu√ß√£o.
                        """)
                else:
                    st.warning("N√£o foi poss√≠vel gerar a visualiza√ß√£o 3D do sistema.")
            except Exception as e:
                st.error(f"Erro ao gerar o gr√°fico 3D: {str(e)}")
                
        else:
            st.info("A visualiza√ß√£o gr√°fica est√° dispon√≠vel apenas para sistemas com 2 ou 3 vari√°veis.")

def show_theory_page():
    st.title("üìö Teoria dos Sistemas Lineares")
    
    theory_topics = {
        "Introdu√ß√£o aos Sistemas Lineares": {
            "content": """
            # Introdu√ß√£o aos Sistemas Lineares
            
            Um **sistema de equa√ß√µes lineares** √© um conjunto de uma ou mais equa√ß√µes lineares envolvendo as mesmas vari√°veis.
            
            ## Defini√ß√£o Formal
            
            Em nota√ß√£o matem√°tica, um sistema linear de m equa√ß√µes e n inc√≥gnitas pode ser escrito como:
            
            $$
            \\begin{align}
            a_{11}x_1 + a_{12}x_2 + \\ldots + a_{1n}x_n &= b_1\\\\
            a_{21}x_1 + a_{22}x_2 + \\ldots + a_{2n}x_n &= b_2\\\\
            \\vdots\\\\
            a_{m1}x_1 + a_{m2}x_2 + \\ldots + a_{mn}x_n &= b_m
            \\end{align}
            $$
            
            Onde:
            - $a_{ij}$ s√£o os coeficientes das inc√≥gnitas
            - $x_j$ s√£o as inc√≥gnitas (ou vari√°veis)
            - $b_i$ s√£o os termos independentes

            ## Representa√ß√£o Matricial
            
            O sistema linear tamb√©m pode ser representado na forma matricial:
            
            $$
            A\\mathbf{x} = \\mathbf{b}
            $$
            
            Onde:
            - $A$ √© a matriz dos coeficientes ($m \\times n$)
            - $\\mathbf{x}$ √© o vetor das inc√≥gnitas ($n \\times 1$)
            - $\\mathbf{b}$ √© o vetor dos termos independentes ($m \\times 1$)
            
            ## Tipos de Sistemas
            
            Um sistema linear pode ser:
            1. **Determinado**: Possui exatamente uma solu√ß√£o
            2. **Indeterminado**: Possui infinitas solu√ß√µes
            3. **Imposs√≠vel**: N√£o possui solu√ß√£o
            
            ## Import√¢ncia
            
            Os sistemas lineares s√£o fundamentais na matem√°tica aplicada e aparecem em diversos contextos:
            - F√≠sica (equil√≠brio de for√ßas, circuitos el√©tricos)
            - Economia (modelos de pre√ßo, an√°lise de insumo-produto)
            - Engenharia (an√°lise estrutural, processamento de sinais)
            - Computa√ß√£o gr√°fica (transforma√ß√µes geom√©tricas)
            """
        },
        "Classifica√ß√£o de Sistemas Lineares": {
            "content": """
            # Classifica√ß√£o de Sistemas Lineares
            
            ## Sistemas Poss√≠veis e Determinados (SPD)
            
            Um sistema √© **poss√≠vel e determinado** quando possui **exatamente uma solu√ß√£o**.
            
            **Caracter√≠sticas**:
            - O determinante da matriz dos coeficientes √© diferente de zero (det(A) ‚â† 0)
            - O n√∫mero de equa√ß√µes linearmente independentes √© igual ao n√∫mero de inc√≥gnitas
            - O posto da matriz dos coeficientes √© igual ao posto da matriz ampliada e igual ao n√∫mero de inc√≥gnitas
            
            **Interpreta√ß√£o geom√©trica**:
            - Em 2D: duas retas que se intersectam em um √∫nico ponto
            - Em 3D: tr√™s planos que se intersectam em um √∫nico ponto
            
            ## Sistemas Poss√≠veis e Indeterminados (SPI)
            
            Um sistema √© **poss√≠vel e indeterminado** quando possui **infinitas solu√ß√µes**.
            
            **Caracter√≠sticas**:
            - O posto da matriz dos coeficientes √© igual ao posto da matriz ampliada
            - O posto √© menor que o n√∫mero de inc√≥gnitas
            
            **Interpreta√ß√£o geom√©trica**:
            - Em 2D: retas coincidentes (sobrepostas)
            - Em 3D: planos que se intersectam em uma reta ou coincidem
            
            ## Sistemas Imposs√≠veis (SI)
            
            Um sistema √© **imposs√≠vel** quando **n√£o possui solu√ß√£o**.
            
            **Caracter√≠sticas**:
            - O posto da matriz dos coeficientes √© menor que o posto da matriz ampliada
            
            **Interpreta√ß√£o geom√©trica**:
            - Em 2D: retas paralelas (n√£o se intersectam)
            - Em 3D: planos paralelos ou que se intersectam sem um ponto comum a todos
            
            ## Teorema de Rouch√©-Capelli
            
            O teorema estabelece que:
            
            - Um sistema √© **compat√≠vel** (tem solu√ß√£o) se e somente se o posto da matriz dos coeficientes √© igual ao posto da matriz ampliada.
            
            - Seja r = posto da matriz dos coeficientes = posto da matriz ampliada:
              - Se r = n (n√∫mero de inc√≥gnitas), o sistema √© SPD
              - Se r < n, o sistema √© SPI
            
            - Se o posto da matriz dos coeficientes < posto da matriz ampliada, o sistema √© SI
            """
        },
        "M√©todo de Elimina√ß√£o de Gauss": {
            "content": """
            # M√©todo de Elimina√ß√£o de Gauss
            
            O m√©todo de Elimina√ß√£o de Gauss √© um dos algoritmos mais importantes para resolver sistemas lineares. Consiste em transformar o sistema em uma forma triangular superior (escalonada) atrav√©s de opera√ß√µes elementares.
            
            ## Opera√ß√µes Elementares
            
            As opera√ß√µes elementares permitidas s√£o:
            1. Trocar a posi√ß√£o de duas equa√ß√µes
            2. Multiplicar uma equa√ß√£o por uma constante n√£o nula
            3. Substituir uma equa√ß√£o pela soma dela com um m√∫ltiplo de outra equa√ß√£o
            
            ## Algoritmo
            
            O m√©todo pode ser dividido em duas etapas:
            
            ### 1. Elimina√ß√£o para frente (Forward Elimination)
            
            Nesta fase, transformamos a matriz aumentada [A|b] em uma matriz triangular superior. Para cada linha i da matriz:
            
            - Encontrar o piv√¥ (elemento n√£o nulo na posi√ß√£o i,i)
            - Para cada linha j abaixo da linha i:
              - Calcular o fator de elimina√ß√£o: f = a_ji / a_ii
              - Subtrair da linha j a linha i multiplicada por f
            
            ### 2. Substitui√ß√£o reversa (Back Substitution)
            
            Uma vez obtida a forma triangular, resolvemos o sistema de tr√°s para frente:
            
            - Calcular o valor da √∫ltima vari√°vel
            - Substituir esse valor nas equa√ß√µes anteriores para encontrar as demais vari√°veis
            
            ## Elimina√ß√£o Gaussiana com Pivoteamento Parcial
            
            Para melhorar a estabilidade num√©rica, √© comum usar pivoteamento parcial:
            
            - A cada passo, escolher como piv√¥ o elemento de maior valor absoluto na coluna atual
            - Trocar linhas para que este elemento fique na posi√ß√£o diagonal
            
            ## Exemplo
            
            Considere o sistema:
            
            $$
            \\begin{align}
            x + y + z &= 6\\\\
            2x - y + z &= 3\\\\
            x + 2y + 3z &= 14
            \\end{align}
            $$
            
            **Matriz aumentada inicial**:
            
            $$
            \\begin{bmatrix}
            1 & 1 & 1 & | & 6 \\\\
            2 & -1 & 1 & | & 3 \\\\
            1 & 2 & 3 & | & 14
            \\end{bmatrix}
            $$
            
            **Ap√≥s elimina√ß√£o para frente**:
            
            $$
            \\begin{bmatrix}
            1 & 1 & 1 & | & 6 \\\\
            0 & -3 & -1 & | & -9 \\\\
            0 & 0 & 5/3 & | & 5
            \\end{bmatrix}
            $$
            
            **Substitui√ß√£o reversa**:
            - Da √∫ltima linha: z = 3
            - Da segunda linha: -3y - 3 = -9, portanto y = 2
            - Da primeira linha: x + 2 + 3 = 6, portanto x = 1
            
            **Solu√ß√£o**: x = 1, y = 2, z = 3
            """
        },
        "Regra de Cramer": {
            "content": """
            # Regra de Cramer
            
            A Regra de Cramer √© um m√©todo para resolver sistemas lineares usando determinantes. √â aplic√°vel apenas a sistemas com mesmo n√∫mero de equa√ß√µes e inc√≥gnitas, onde o determinante da matriz dos coeficientes √© diferente de zero (sistemas SPD).
            
            ## Procedimento
            
            Para um sistema AX = B:
            
            1. Calcular o determinante D da matriz A
            2. Para cada vari√°vel x·µ¢:
               - Substituir a coluna i da matriz A pela coluna B, obtendo a matriz A·µ¢
               - Calcular o determinante D·µ¢
               - A solu√ß√£o para x·µ¢ √© dada por x·µ¢ = D·µ¢/D
            
            ## F√≥rmula
            
            Para um sistema 2√ó2:
            
            $$
            \\begin{align}
            a_1x + b_1y &= c_1\\\\
            a_2x + b_2y &= c_2
            \\end{align}
            $$
            
            As solu√ß√µes s√£o:
            
            $$
            x = \\frac{\\begin{vmatrix} c_1 & b_1 \\\\ c_2 & b_2 \\end{vmatrix}}{\\begin{vmatrix} a_1 & b_1 \\\\ a_2 & b_2 \\end{vmatrix}} = \\frac{c_1b_2 - b_1c_2}{a_1b_2 - b_1a_2}
            $$
            
            $$
            y = \\frac{\\begin{vmatrix} a_1 & c_1 \\\\ a_2 & c_2 \\end{vmatrix}}{\\begin{vmatrix} a_1 & b_1 \\\\ a_2 & b_2 \\end{vmatrix}} = \\frac{a_1c_2 - c_1a_2}{a_1b_2 - b_1a_2}
            $$
            
            ## Exemplo
            
            Considere o sistema:
            
            $$
            \\begin{align}
            2x + 3y &= 8\\\\
            4x - y &= 1
            \\end{align}
            $$
            
            **Determinante principal**:
            
            $$
            D = \\begin{vmatrix} 2 & 3 \\\\ 4 & -1 \\end{vmatrix} = 2 \\times (-1) - 3 \\times 4 = -2 - 12 = -14
            $$
            
            **Determinante para x**:
            
            $$
            D_x = \\begin{vmatrix} 8 & 3 \\\\ 1 & -1 \\end{vmatrix} = 8 \\times (-1) - 3 \\times 1 = -8 - 3 = -11
            $$
            
            **Determinante para y**:
            
            $$
            D_y = \\begin{vmatrix} 2 & 8 \\\\ 4 & 1 \\end{vmatrix} = 2 \\times 1 - 8 \\times 4 = 2 - 32 = -30
            $$
            
            **Solu√ß√£o**:
            
            $$
            x = \\frac{D_x}{D} = \\frac{-11}{-14} = \\frac{11}{14}
            $$
            
            $$
            y = \\frac{D_y}{D} = \\frac{-30}{-14} = \\frac{15}{7}
            $$
            
            ## Vantagens e Desvantagens
            
            **Vantagens**:
            - M√©todo direto (n√£o iterativo)
            - F√°cil de entender e aplicar para sistemas pequenos
            
            **Desvantagens**:
            - Aplic√°vel apenas a sistemas quadrados (n√ón) com determinante n√£o nulo
            - Computacionalmente ineficiente para sistemas grandes
            - N√£o √© recomendado para sistemas mal condicionados
            """
        },
        "M√©todo da Matriz Inversa": {
            "content": """
            # M√©todo da Matriz Inversa
            
            O m√©todo da matriz inversa √© uma abordagem direta para resolver sistemas lineares na forma AX = B, onde A √© uma matriz quadrada invers√≠vel.
            
            ## Procedimento
            
            1. Verificar se a matriz A √© invers√≠vel (det(A) ‚â† 0)
            2. Calcular a matriz inversa A‚Åª¬π
            3. Multiplicar ambos os lados da equa√ß√£o por A‚Åª¬π: A‚Åª¬π(AX) = A‚Åª¬πB
            4. Simplificar: X = A‚Åª¬πB
            
            ## C√°lculo da Matriz Inversa
            
            Para uma matriz 2√ó2:
            
            $$
            \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}^{-1} = \\frac{1}{ad-bc} \\begin{bmatrix} d & -b \\\\ -c & a \\end{bmatrix}
            $$
            
            Para matrizes maiores, pode-se usar:
            - M√©todo da matriz adjunta
            - Elimina√ß√£o gaussiana
            - Decomposi√ß√£o LU
            
            ## Exemplo
            
            Considere o sistema:
            
            $$
            \\begin{align}
            2x + y &= 5\\\\
            3x + 4y &= 11
            \\end{align}
            $$
            
            Na forma matricial:
            
            $$
            \\begin{bmatrix} 2 & 1 \\\\ 3 & 4 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} 5 \\\\ 11 \\end{bmatrix}
            $$
            
            **Determinante**:
            
            $$
            \\det(A) = 2 \\times 4 - 1 \\times 3 = 8 - 3 = 5
            $$
            
            **Matriz inversa**:
            
            $$
            A^{-1} = \\frac{1}{5} \\begin{bmatrix} 4 & -1 \\\\ -3 & 2 \\end{bmatrix} = \\begin{bmatrix} 4/5 & -1/5 \\\\ -3/5 & 2/5 \\end{bmatrix}
            $$
            
            **Solu√ß√£o**:
            
            $$
            \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} 4/5 & -1/5 \\\\ -3/5 & 2/5 \\end{bmatrix} \\begin{bmatrix} 5 \\\\ 11 \\end{bmatrix} = \\begin{bmatrix} 4/5 \\times 5 - 1/5 \\times 11 \\\\ -3/5 \\times 5 + 2/5 \\times 11 \\end{bmatrix} = \\begin{bmatrix} 4 - 11/5 \\\\ -3 + 22/5 \\end{bmatrix} = \\begin{bmatrix} 9/5 \\\\ 7/5 \\end{bmatrix}
            $$
            
            Portanto, x = 9/5 e y = 7/5.
            
            ## Vantagens e Desvantagens
            
            **Vantagens**:
            - M√©todo direto e elegante
            - √ötil quando precisamos resolver m√∫ltiplos sistemas com a mesma matriz de coeficientes
            
            **Desvantagens**:
            - Aplic√°vel apenas a sistemas quadrados (n√ón) com determinante n√£o nulo
            - Computacionalmente ineficiente para sistemas grandes
            - Pode ser numericamente inst√°vel para matrizes mal condicionadas
            """
        },
        "Aplica√ß√µes de Sistemas Lineares": {
            "content": """
            # Aplica√ß√µes de Sistemas Lineares
            
            Os sistemas de equa√ß√µes lineares s√£o ferramentas fundamentais em diversas √°reas. Veja algumas aplica√ß√µes importantes:
            
            ## F√≠sica e Engenharia
            
            ### An√°lise de Circuitos El√©tricos
            - Leis de Kirchhoff: correntes em um n√≥ e tens√µes em um la√ßo
            - Cada equa√ß√£o representa a conserva√ß√£o de corrente ou tens√£o
            
            ### Est√°tica e Din√¢mica
            - Equil√≠brio de for√ßas e momentos em estruturas
            - An√°lise de treli√ßas e vigas
            
            ### Transfer√™ncia de Calor
            - Modelagem de problemas de condu√ß√£o t√©rmica
            - M√©todos de diferen√ßas finitas para equa√ß√µes diferenciais
            
            ## Economia
            
            ### An√°lise de Insumo-Produto de Leontief
            - Modelagem das interdepend√™ncias entre diferentes setores da economia
            - Previs√£o de como mudan√ßas em um setor afetam outros setores
            
            ### Otimiza√ß√£o e Programa√ß√£o Linear
            - Maximiza√ß√£o de lucro ou minimiza√ß√£o de custos
            - Aloca√ß√£o √≥tima de recursos limitados
            
            ## Qu√≠mica
            
            ### Balanceamento de Equa√ß√µes Qu√≠micas
            - Cada elemento forma uma equa√ß√£o linear
            - Os coeficientes estequiom√©tricos s√£o as inc√≥gnitas
            
            ### Equil√≠brio Qu√≠mico
            - Determina√ß√£o de concentra√ß√µes em equil√≠brio
            
            ## Computa√ß√£o Gr√°fica
            
            ### Transforma√ß√µes Geom√©tricas
            - Rota√ß√£o, transla√ß√£o e escala de objetos
            - Representadas como transforma√ß√µes matriciais
            
            ### Renderiza√ß√£o 3D
            - Sistemas para determinar proje√ß√µes de objetos 3D em telas 2D
            
            ## Problemas de Mistura
            
            ### Farmacologia
            - Mistura de componentes para atingir concentra√ß√µes espec√≠ficas
            - Formula√ß√£o de medicamentos
            
            ### Processamento de Alimentos
            - Mistura de ingredientes para atingir perfis nutricionais
            
            ## Tr√°fego e Transporte
            
            ### Fluxo de Redes
            - Modelagem de fluxo de tr√°fego em redes de transporte
            - Otimiza√ß√£o de rotas
            
            ## Exemplo Pr√°tico: Problema de Mistura
            
            **Problema**: Uma farm√°cia precisa preparar 100 ml de uma solu√ß√£o com concentra√ß√£o de 25% de um princ√≠pio ativo. Disp√µe-se de solu√ß√µes com concentra√ß√µes de 10%, 20% e 50%. Quanto de cada solu√ß√£o deve ser usado?
            
            **Modelagem**:
            - Sejam x, y e z as quantidades (em ml) das solu√ß√µes com 10%, 20% e 50%
            - Equa√ß√£o 1: x + y + z = 100 (volume total)
            - Equa√ß√£o 2: 0.10x + 0.20y + 0.50z = 0.25 √ó 100 (quantidade do princ√≠pio ativo)
            
            **Sistema**:
            
            $$
            \\begin{align}
            x + y + z &= 100\\\\
            0.1x + 0.2y + 0.5z &= 25
            \\end{align}
            $$
            
            Este sistema tem infinitas solu√ß√µes (SPI). Uma poss√≠vel estrat√©gia √© fixar um valor para uma das vari√°veis e resolver para as outras duas.
            """
        }
    }
    
    # Selecionar t√≥pico da teoria
    col1, col2 = st.columns([1, 3])
    
    with col1:
        selected_topic = st.radio(
            "T√≥picos:",
            list(theory_topics.keys()),
            key="theory_topic"
        )
        
        st.markdown("---")
        st.markdown("### Material de Apoio")
        
        # Bot√£o para baixar o material em PDF (simulado)
        if st.button("üì• Baixar Material em PDF"):
            st.success("Download iniciado! (Simula√ß√£o)")
        
        # Bot√£o para acessar videoaulas (simulado)
        if st.button("üé¨ Acessar Videoaulas"):
            st.info("Redirecionando para as videoaulas... (Simula√ß√£o)")
    
    with col2:
        st.markdown(theory_topics[selected_topic]["content"])

def show_exercises_page():
    st.title("‚úèÔ∏è Exerc√≠cios de Sistemas Lineares")
    
    tab1, tab2 = st.tabs(["üìù Praticar", "üìã Hist√≥rico"])
    
    with tab1:
        st.subheader("Pratique seus conhecimentos")
        
        difficulty = st.select_slider(
            "N√≠vel de dificuldade:",
            options=["F√°cil", "M√©dio", "Dif√≠cil"],
            value="M√©dio"
        )
        
        if "current_exercise" not in st.session_state or st.button("Gerar Novo Exerc√≠cio"):
            A, b, question, equations, solution = get_practice_exercise(difficulty)
            st.session_state.current_exercise = {
                "A": A,
                "b": b,
                "question": question,
                "equations": equations,
                "solution": solution,
                "difficulty": difficulty,
                "system_type": classify_system(A, b)
            }
        
        # Mostrar o exerc√≠cio atual
        st.markdown(f"### {st.session_state.current_exercise['question']}")
        
        for i, eq in enumerate(st.session_state.current_exercise["equations"]):
            st.markdown(f"{i+1}. {eq}")
        
        # Adicionar visualiza√ß√£o se for sistema 2x2 ou 3x3
        A = st.session_state.current_exercise["A"]
        b = st.session_state.current_exercise["b"]
        
        if A.shape[1] == 2:
            with st.expander("Visualiza√ß√£o Gr√°fica", expanded=False):
                try:
                    fig = plot_2d_system(A, b)
                    if fig:
                        st.pyplot(fig)
                except:
                    st.warning("N√£o foi poss√≠vel gerar a visualiza√ß√£o do sistema.")
        elif A.shape[1] == 3:
            with st.expander("Visualiza√ß√£o 3D", expanded=False):
                try:
                    fig = plot_3d_system(A, b)
                    if fig:
                        st.plotly_chart(fig, use_container_width=True)
                except:
                    st.warning("N√£o foi poss√≠vel gerar a visualiza√ß√£o 3D do sistema.")
        
        # Campo para resposta do usu√°rio
        user_answer = st.text_input(
            "Sua resposta:",
            help="Para SPD, insira os valores das vari√°veis separados por espa√ßo ou v√≠rgula. Para SPI ou SI, classifique o sistema."
        )
        
        # Verificar resposta
        if st.button("Verificar Resposta"):
            if user_answer:
                is_correct, message = check_user_answer(
                    user_answer, 
                    st.session_state.current_exercise["solution"], 
                    st.session_state.current_exercise["system_type"]
                )
                
                if is_correct:
                    st.success(f"‚úÖ Correto! {message}")
                    
                    # Salvar no hist√≥rico
                    if "exercise_history" not in st.session_state:
                        st.session_state.exercise_history = []
                    
                    st.session_state.exercise_history.append({
                        "question": st.session_state.current_exercise["question"],
                        "equations": st.session_state.current_exercise["equations"],
                        "answer": user_answer,
                        "is_correct": True,
                        "difficulty": st.session_state.current_exercise["difficulty"]
                    })
                else:
                    st.error(f"‚ùå Incorreto. {message}")
            else:
                st.warning("Por favor, insira uma resposta.")
        
        # Bot√£o para ver a solu√ß√£o
        if st.button("Ver Solu√ß√£o"):
            st.markdown("### Solu√ß√£o Detalhada")
            
            system_type = st.session_state.current_exercise["system_type"]
            st.markdown(f"**Classifica√ß√£o do Sistema**: {system_type}")
            
            if system_type == "Sistema Poss√≠vel e Determinado (SPD)":
                solution = st.session_state.current_exercise["solution"]
                
                # Mostrar solu√ß√£o usando elimina√ß√£o de Gauss
                steps, _ = gaussian_elimination_steps(A, b)
                
                st.markdown("**M√©todo de Elimina√ß√£o de Gauss:**")
                for step in steps:
                    st.write(step)
                
                st.markdown("**Resposta final:**")
                var_names = ["x", "y", "z", "w"][:A.shape[1]]
                for i, val in enumerate(solution):
                    st.markdown(f"- {var_names[i]} = {val}")
                
            elif system_type == "Sistema Poss√≠vel e Indeterminado (SPI)":
                st.write("""
                Este sistema possui infinitas solu√ß√µes. 
                
                A matriz dos coeficientes tem posto menor que o n√∫mero de vari√°veis, o que significa 
                que algumas vari√°veis podem ser expressas em termos de outras (par√¢metros livres).
                """)
                
                # Tentar obter solu√ß√£o simb√≥lica
                try:
                    symbolic_solution, var_symbols = sympy_solve_system(A, b)
                    
                    if symbolic_solution:
                        st.markdown("**Solu√ß√£o Param√©trica:**")
                        
                        if isinstance(symbolic_solution, dict):
                            for var, expr in symbolic_solution.items():
                                st.latex(f"{sp.latex(var)} = {sp.latex(expr)}")
                        else:
                            st.latex(sp.latex(symbolic_solution))
                except:
                    st.warning("N√£o foi poss√≠vel obter uma representa√ß√£o param√©trica da solu√ß√£o.")
                
            else:  # SI
                st.write("""
                Este sistema n√£o possui solu√ß√£o. 
                
                O posto da matriz de coeficientes √© menor que o posto da matriz ampliada, o que significa 
                que o sistema cont√©m equa√ß√µes inconsistentes entre si.
                """)
            
            # Salvar no hist√≥rico mesmo se o usu√°rio viu a solu√ß√£o sem tentar
            if "exercise_history" not in st.session_state:
                st.session_state.exercise_history = []
            
            # Verificar se este exerc√≠cio j√° est√° no hist√≥rico para n√£o duplicar
            already_in_history = False
            for entry in st.session_state.exercise_history:
                if entry["equations"] == st.session_state.current_exercise["equations"]:
                    already_in_history = True
                    break
            
            if not already_in_history:
                st.session_state.exercise_history.append({
                    "question": st.session_state.current_exercise["question"],
                    "equations": st.session_state.current_exercise["equations"],
                    "answer": "Solu√ß√£o vista",
                    "is_correct": False,
                    "difficulty": st.session_state.current_exercise["difficulty"]
                })
    
    with tab2:
        if "exercise_history" not in st.session_state or not st.session_state.exercise_history:
            st.info("Seu hist√≥rico de exerc√≠cios aparecer√° aqui ap√≥s voc√™ resolver alguns problemas.")
        else:
            st.subheader("Seu hist√≥rico de exerc√≠cios")
            
            # Estat√≠sticas
            total = len(st.session_state.exercise_history)
            correct = sum(1 for e in st.session_state.exercise_history if e["is_correct"])
            
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Total de Exerc√≠cios", total)
            with col2:
                st.metric("Acertos", correct)
            with col3:
                st.metric("Taxa de Acerto", f"{int(correct/total*100)}%" if total > 0 else "0%")
            
            # Tabela de hist√≥rico
            history_data = []
            for i, exercise in enumerate(st.session_state.exercise_history[::-1]):  # Mais recente primeiro
                history_data.append({
                    "ID": i+1,
                    "N√≠vel": exercise["difficulty"],
                    "Quest√£o": "\n".join(exercise["equations"]),
                    "Resposta": exercise["answer"],
                    "Resultado": "‚úÖ Correto" if exercise["is_correct"] else "‚ùå Incorreto"
                })
            
            history_df = pd.DataFrame(history_data)
            st.dataframe(history_df, use_container_width=True)
            
            # Bot√£o para limpar hist√≥rico
            if st.button("Limpar Hist√≥rico"):
                st.session_state.exercise_history = []
                st.experimental_rerun()

def show_examples_page():
    st.title("üìã Exemplos Resolvidos")
    
    example_types = [
        "Sistema 2√ó2 (SPD)",
        "Sistema 2√ó2 (SPI)",
        "Sistema 2√ó2 (SI)",
        "Sistema 3√ó3 (SPD)",
        "Sistema 3√ó3 (SPI)",
        "Sistema 3√ó3 (SI)",
        "Aplica√ß√£o: Mistura",
        "Aplica√ß√£o: Circuitos"
    ]
    
    col1, col2 = st.columns([1, 3])
    
    with col1:
        selected_example = st.radio(
            "Selecione um exemplo:",
            example_types,
            key="example_type"
        )
        
        st.markdown("---")
        st.markdown("### M√©todos de Resolu√ß√£o")
        
        methods = [
            "Elimina√ß√£o de Gauss",
            "Regra de Cramer",
            "Matriz Inversa"
        ]
        
        selected_methods = st.multiselect(
            "Mostrar solu√ß√£o por:",
            methods,
            default=["Elimina√ß√£o de Gauss"]
        )
    
    with col2:
        example = get_example_system(selected_example)
        
        st.header(example["title"])
        
        st.markdown("### Sistema de Equa√ß√µes")
        for i, eq in enumerate(example["equations"]):
            st.write(f"Equa√ß√£o {i+1}: {eq}")
        
        # Visualiza√ß√£o gr√°fica quando aplic√°vel
        if example["A"] is not None and example["b"] is not None:
            if example["A"].shape[1] == 2:
                st.markdown("### Visualiza√ß√£o Gr√°fica")
                try:
                    fig = plot_2d_system(example["A"], example["b"])
                    if fig:
                        st.pyplot(fig)
                except:
                  st.warning("N√£o foi poss√≠vel gerar a visualiza√ß√£o do sistema.")
            elif example["A"].shape[1] == 3:
                st.markdown("### Visualiza√ß√£o 3D")
                try:
                    fig = plot_3d_system(example["A"], example["b"])
                    if fig:
                        st.plotly_chart(fig, use_container_width=True)
                except:
                    st.warning("N√£o foi poss√≠vel gerar a visualiza√ß√£o 3D do sistema.")
        
        st.markdown("### Solu√ß√£o")
        st.markdown(example["solution"])
        
        # Mostrar m√©todos de resolu√ß√£o selecionados
        if "Elimina√ß√£o de Gauss" in selected_methods and example["A"] is not None and example["b"] is not None:
            st.markdown("### M√©todo de Elimina√ß√£o de Gauss")
            
            try:
                steps, solution = gaussian_elimination_steps(example["A"], example["b"])
                
                with st.expander("Ver passos detalhados", expanded=False):
                    for step in steps:
                        st.write(step)
                
                if solution is not None:
                    st.markdown("**Resultado:**")
                    var_names = ["x", "y", "z", "w"][:example["A"].shape[1]]
                    for i, val in enumerate(solution):
                        st.markdown(f"- {var_names[i]} = {val:.4f}")
                else:
                    st.write("Este m√©todo n√£o pode determinar uma solu√ß√£o √∫nica.")
            except:
                st.error("N√£o foi poss√≠vel aplicar o m√©todo de Elimina√ß√£o de Gauss para este sistema.")
        
        if "Regra de Cramer" in selected_methods and example["A"] is not None and example["b"] is not None:
            st.markdown("### Regra de Cramer")
            
            # Verificar se a matriz √© quadrada
            if example["A"].shape[0] == example["A"].shape[1]:
                try:
                    steps, solution = cramer_rule(example["A"], example["b"], detailed=True)
                    
                    with st.expander("Ver passos detalhados", expanded=False):
                        for step in steps:
                            st.write(step)
                    
                    if solution is not None:
                        st.markdown("**Resultado:**")
                        var_names = ["x", "y", "z", "w"][:example["A"].shape[1]]
                        for i, val in enumerate(solution):
                            st.markdown(f"- {var_names[i]} = {val:.4f}")
                    else:
                        st.write("A Regra de Cramer n√£o pode ser aplicada a este sistema (determinante zero).")
                except:
                    st.error("N√£o foi poss√≠vel aplicar a Regra de Cramer para este sistema.")
            else:
                st.info("A Regra de Cramer s√≥ pode ser aplicada a sistemas com o mesmo n√∫mero de equa√ß√µes e inc√≥gnitas.")
        
        if "Matriz Inversa" in selected_methods and example["A"] is not None and example["b"] is not None:
            st.markdown("### M√©todo da Matriz Inversa")
            
            # Verificar se a matriz √© quadrada
            if example["A"].shape[0] == example["A"].shape[1]:
                try:
                    steps, solution = matrix_inverse_method(example["A"], example["b"], detailed=True)
                    
                    with st.expander("Ver passos detalhados", expanded=False):
                        for step in steps:
                            st.write(step)
                    
                    if solution is not None:
                        st.markdown("**Resultado:**")
                        var_names = ["x", "y", "z", "w"][:example["A"].shape[1]]
                        for i, val in enumerate(solution):
                            st.markdown(f"- {var_names[i]} = {val:.4f}")
                    else:
                        st.write("O m√©todo da Matriz Inversa n√£o pode ser aplicado a este sistema (matriz singular).")
                except:
                    st.error("N√£o foi poss√≠vel aplicar o m√©todo da Matriz Inversa para este sistema.")
            else:
                st.info("O m√©todo da Matriz Inversa s√≥ pode ser aplicado a sistemas com o mesmo n√∫mero de equa√ß√µes e inc√≥gnitas.")
        
        st.markdown("### Explica√ß√£o")
        st.markdown(example["explanation"])

def show_reference_page():
    st.title("üìö Refer√™ncia R√°pida")
    
    reference_topics = [
        "Classifica√ß√£o de Sistemas",
        "M√©todo de Elimina√ß√£o de Gauss",
        "Regra de Cramer",
        "M√©todo da Matriz Inversa",
        "Interpreta√ß√£o Geom√©trica",
        "Teorema de Rouch√©-Capelli"
    ]
    
    col1, col2 = st.columns([1, 3])
    
    with col1:
        selected_topic = st.radio(
            "T√≥picos:",
            reference_topics,
            key="reference_topic"
        )
        
        st.markdown("---")
        
        # Adicionar funcionalidade de download do cart√£o de refer√™ncia
        st.markdown("### Exportar Refer√™ncia")
        
        if st.button("üì• Baixar como PDF"):
            st.success("Download iniciado! (Simula√ß√£o)")
            
        if st.button("üì± Vers√£o para Celular"):
            st.success("Vers√£o para celular dispon√≠vel! (Simula√ß√£o)")
    
    with col2:
        st.markdown(get_reference_card(selected_topic))
        
        # Adicionar exemplos compactos
        if selected_topic == "Classifica√ß√£o de Sistemas":
            with st.expander("Exemplos de Classifica√ß√£o", expanded=False):
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.markdown("**SPD**")
                    st.latex(r"""
                    \begin{align}
                    x + y &= 5\\
                    2x - y &= 1
                    \end{align}
                    """)
                    st.markdown("Solu√ß√£o √∫nica: (2, 3)")
                
                with col2:
                    st.markdown("**SPI**")
                    st.latex(r"""
                    \begin{align}
                    2x + 3y &= 6\\
                    4x + 6y &= 12
                    \end{align}
                    """)
                    st.markdown("Infinitas solu√ß√µes: $x = t$, $y = \frac{6-2t}{3}$")
                
                with col3:
                    st.markdown("**SI**")
                    st.latex(r"""
                    \begin{align}
                    2x + 3y &= 6\\
                    2x + 3y &= 8
                    \end{align}
                    """)
                    st.markdown("Sem solu√ß√£o (inconsistente)")
        
        elif selected_topic == "M√©todo de Elimina√ß√£o de Gauss":
            with st.expander("Exemplo Passo a Passo", expanded=False):
                st.markdown("""
                **Sistema**:
                
                $x + y + z = 6$
                
                $2x - y + z = 3$
                
                $x + 2y + 3z = 14$
                
                **Matriz aumentada inicial**:
                
                $\\begin{bmatrix}
                1 & 1 & 1 & | & 6 \\\\
                2 & -1 & 1 & | & 3 \\\\
                1 & 2 & 3 & | & 14
                \\end{bmatrix}$
                
                **Passo 1**: Eliminar x da segunda linha
                
                $L_2 = L_2 - 2L_1$
                
                $\\begin{bmatrix}
                1 & 1 & 1 & | & 6 \\\\
                0 & -3 & -1 & | & -9 \\\\
                1 & 2 & 3 & | & 14
                \\end{bmatrix}$
                
                **Passo 2**: Eliminar x da terceira linha
                
                $L_3 = L_3 - L_1$
                
                $\\begin{bmatrix}
                1 & 1 & 1 & | & 6 \\\\
                0 & -3 & -1 & | & -9 \\\\
                0 & 1 & 2 & | & 8
                \\end{bmatrix}$
                
                **Passo 3**: Eliminar y da terceira linha
                
                $L_3 = L_3 + \\frac{1}{3}L_2$
                
                $\\begin{bmatrix}
                1 & 1 & 1 & | & 6 \\\\
                0 & -3 & -1 & | & -9 \\\\
                0 & 0 & \\frac{5}{3} & | & 5
                \\end{bmatrix}$
                
                **Substitui√ß√£o reversa**:
                
                $z = \\frac{5}{\\frac{5}{3}} = 3$
                
                $y = \\frac{-9 - (-1)(3)}{-3} = \\frac{-9 + 3}{-3} = 2$
                
                $x = 6 - 1(2) - 1(3) = 6 - 2 - 3 = 1$
                
                **Solu√ß√£o**: $(1, 2, 3)$
                """)

# Executar a aplica√ß√£o
if __name__ == "__main__":
    main()
